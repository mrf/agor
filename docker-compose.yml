# Agor Development Environment
#
# This Docker Compose setup supports:
# - Multiple worktrees running simultaneously (via -p flag)
# - Both SQLite (default) and PostgreSQL databases
# - Isolated environments per worktree (separate volumes, ports, node_modules)
#
# ==============================================================================
# Quick Start
# ==============================================================================
#
# Single worktree (SQLite):
#   docker compose up
#
# Multiple worktrees (recommended - see .agor.yml):
#   docker compose -p agor-postgres-support up -d
#   docker compose -p agor-main up -d
#
# PostgreSQL (optional - for multi-user or production-like setup):
#   docker compose --profile postgres up
#
# Executor isolation (test process-level security):
#   AGOR_USE_EXECUTOR=true docker compose up
#
# Or set in .env file:
#   COMPOSE_PROFILES=postgres
#   AGOR_USE_EXECUTOR=true
#   docker compose up
#
# ==============================================================================
# Multi-Worktree Isolation
# ==============================================================================
#
# The -p (project name) flag creates completely isolated environments:
# - Separate Docker image per worktree (image tag includes project name)
# - Separate volumes (node_modules, database, config)
# - Separate networks and containers
# - Separate ports (using unique_id offset in .agor.yml)
#
# Dependencies are smart-synced at container startup:
# - First boot: Installs packages and caches in named volume
# - Subsequent boots: Only reinstalls if pnpm-lock.yaml changed
# This ensures fast boot times (~2-3s) while respecting per-branch dependencies.
#
# ==============================================================================
# Database Modes
# ==============================================================================
#
# 1. SQLite Mode (default):
#    - No PostgreSQL container runs
#    - Database stored in ~/.agor/agor.db (inside container volume)
#    - Lightweight, perfect for single-user development
#
# 2. PostgreSQL Mode (with --profile postgres):
#    - PostgreSQL container runs automatically
#    - Database in postgres-data volume
#    - Better for multi-user scenarios or testing production setup
#    - Set DATABASE_URL or it auto-connects to postgres:5432
#
# ==============================================================================
# Configuration
# ==============================================================================
#
# Copy .env.example to .env and customize:
#   cp .env.example .env
#
# Key environment variables:
#   AGOR_DB_DIALECT              - 'sqlite' (default) or 'postgresql'
#   DATABASE_URL                 - Full PostgreSQL connection URL (when using PostgreSQL)
#   POSTGRES_DB                  - Database name (default: agor)
#   POSTGRES_USER                - Database user (default: agor)
#   POSTGRES_PASSWORD            - Database password (default: agor_dev_secret)
#
# Executor isolation (security feature):
#   AGOR_USE_EXECUTOR            - Enable executor isolation (default: false)
#   AGOR_EXECUTOR_IMPERSONATION  - Impersonation mode: 'sudo' or 'disabled' (default: sudo)
#   AGOR_EXECUTOR_USERNAME       - Unix user for executors (default: agor_executor)
#
# ==============================================================================

services:
  agor-dev:
    image: ${COMPOSE_PROJECT_NAME:-agor}-agor-dev
    build:
      context: .
      dockerfile: docker/Dockerfile
      target: development
    # No container_name - allows multiple instances via docker compose -p flag
    ports:
      # Expose daemon port (so browser can connect) - configurable via DAEMON_PORT
      - '${DAEMON_PORT:-3030}:${DAEMON_PORT:-3030}'
      # Expose UI port (configurable via UI_PORT env var)
      - '${UI_PORT:-5173}:${UI_PORT:-5173}'
    environment:
      # Daemon configuration
      - NODE_ENV=development
      - DAEMON_PORT=${DAEMON_PORT:-3030}
      - CORS_ORIGIN=${CORS_ORIGIN:-*}

      # UI configuration
      - UI_PORT=${UI_PORT:-5173}
      # UI connects to daemon via localhost (inside container)
      - VITE_DAEMON_PORT=${DAEMON_PORT:-3030}

      # Database configuration
      # AUTO-DETECT: If postgres container is running, use PostgreSQL; otherwise SQLite
      # This allows `docker compose --profile postgres up` to just work!
      - AGOR_DB_DIALECT=${AGOR_DB_DIALECT:-sqlite}
      - DATABASE_URL=${DATABASE_URL:-}

      # Seed development fixtures (optional, set SEED=true to populate test data)
      # Creates: Agor repo (https://github.com/preset-io/agor.git) + test-worktree
      - SEED=${SEED:-false}

      # Pass through API keys from host (if set)
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - GEMINI_API_KEY=${GEMINI_API_KEY:-}

      # Executor isolation mode (set AGOR_USE_EXECUTOR=true to enable)
      # When enabled, SDK execution runs in isolated subprocess as agor_executor user
      - AGOR_USE_EXECUTOR=${AGOR_USE_EXECUTOR:-false}
      - AGOR_EXECUTOR_IMPERSONATION=${AGOR_EXECUTOR_IMPERSONATION:-sudo}
      - AGOR_EXECUTOR_USERNAME=${AGOR_EXECUTOR_USERNAME:-agor_executor}
    depends_on:
      postgres:
        condition: service_healthy
        required: false # Optional dependency - only needed when postgres profile is active
    volumes:
      # Mount entire repo for hot-reload (source code only)
      - .:/app
      # Use anonymous volumes to exclude node_modules and dist from the source mount
      # This preserves the Docker-built versions (correct OS binaries, pre-built artifacts)
      # Anonymous volumes use the container's built-in files directly - no copy needed!
      - /app/node_modules
      - /app/packages/core/node_modules
      - /app/packages/executor/node_modules
      - /app/packages/agor-live/node_modules
      - /app/apps/agor-daemon/node_modules
      - /app/apps/agor-ui/node_modules
      - /app/apps/agor-docs/node_modules
      - /app/apps/agor-cli/node_modules
      # Persist entire home directory (database, config, agent auth tokens, etc.)
      - agor-home:/home/agor
      # Mount SSH keys for git authentication (dev only)
      - ~/.ssh:/home/agor/.ssh:ro
    stdin_open: true
    tty: true

  # PostgreSQL database (ONLY active with --profile postgres)
  # Usage: docker-compose --profile postgres up
  postgres:
    profiles: ['postgres'] # Optional service - only runs when profile is specified
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-agor}
      POSTGRES_USER: ${POSTGRES_USER:-agor}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-agor_dev_secret}
      # Performance tuning for development
      POSTGRES_INITDB_ARGS: '-E UTF8 --locale=C'
    ports:
      - '${POSTGRES_PORT:-5432}:5432'
    volumes:
      - postgres-data:/var/lib/postgresql/data
      # Init script to grant permissions (runs only on first startup)
      - ./docker/postgres-init.sql:/docker-entrypoint-initdb.d/01-init.sql:ro
    healthcheck:
      test:
        [
          'CMD-SHELL',
          'pg_isready -U ${POSTGRES_USER:-agor} -d ${POSTGRES_DB:-agor} && psql -U ${POSTGRES_USER:-agor} -d ${POSTGRES_DB:-agor} -tAc "SELECT 1 FROM information_schema.schemata WHERE schema_name=''drizzle''" | grep -q 1',
        ]
      interval: 2s
      timeout: 3s
      retries: 10
      start_period: 15s
    restart: unless-stopped

volumes:
  # Named volume - unique per docker-compose project (via -p flag)
  # Each worktree gets its own isolated volume for:
  # - Database (~/.agor/agor.db)
  # - Config (~/.agor/config.yaml)
  # - Agent auth tokens
  # - Caches, etc.
  agor-home:

  # PostgreSQL data (only created when postgres profile is active)
  postgres-data:
